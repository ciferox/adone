const assert = require("referee").assert;
const refute = require("referee").refute;
const buster = require("bustermove");
const browserify = require("browserify");
const path = require("path");
const after = require("after");
const bl = require("bl");
const spawn = require("child_process").spawn;
const PACKAGE_JSON = path.join(__dirname, "..", "package.json");

buster.testCase("Browserify Bundle", {
    "does not contain package.json"(done) {
        const b = browserify(path.join(__dirname, ".."), { browserField: true })
            .once("error", (error) => {
                assert.fail(error);
                done();
            });
        b.pipeline
            .on("file", (file, id, parent) => {
                refute.equals(file, PACKAGE_JSON);
            });
        b.bundle(done);
    },
    "throws error if missing db factory"(done) {
        const b = browserify(path.join(__dirname, "data/browser-throws.js"), { browserField: true });
        const node = spawn("node");
        const fin = after(2, done);
        node.stderr.pipe(bl((err, buf) => {
            refute(err);
            assert.match(buf.toString(), /InitializationError: First argument must be an abstract-leveldown compliant store/);
            fin();
        }));
        node.on("exit", (code) => {
            assert.equals(code, 1);
            fin();
        });
        b.bundle().pipe(node.stdin);
    },
    "works with valid db factory (memdown)"(done) {
        const b = browserify(path.join(__dirname, "data/browser-works.js"), { browserField: true });
        const node = spawn("node");
        node.on("exit", (code) => {
            assert.equals(code, 0);
            done();
        });
        b.bundle().pipe(node.stdin);
    }
});

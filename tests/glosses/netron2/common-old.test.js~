const {
    is,
    net,
    std: { path },
    netron: { DEFAULT_PORT, ACTION, PEER_STATUS, Netron, Reflection, Context, Public }
} = adone;

let defaultPort = DEFAULT_PORT;
let NETRON_PORT = 32348;

const fixturePath = (relPath) => path.join(__dirname, "..", "fixtures", relPath);

describe("netron", "common", function () {
    this.timeout(10 * 1000);
    let exNetron;
    let superNetron;

    before(async () => {
        defaultPort = await net.util.getPort(defaultPort);
        NETRON_PORT = await net.util.getPort({ exclude: [defaultPort] });
    });

    beforeEach(async () => {
        exNetron = new Netron();
        superNetron = new Netron({ isSuper: true });
    });

    afterEach(async () => {
        await exNetron.disconnect();
        await superNetron.unbind();
    });

    describe("connection", () => {
        it("Peer#disconnect() from client", async (done) => {
            await superNetron.bind();
            const peer = await exNetron.connect();
            assert.ok(superNetron.getPeer(exNetron.uid));
            assert.ok(exNetron.getPeer(superNetron.uid));

            exNetron.on("peer offline", (peer) => {
                assert.equal(peer.uid, superNetron.uid);
                done();
            });

            peer.disconnect();
        });

        it("Peer#disconnect() from server", async (done) => {
            await superNetron.bind();
            await exNetron.connect();

            superNetron.on("peer offline", (peer) => {
                assert.equal(peer.uid, exNetron.uid);
                done();
            });

            superNetron.getPeer(exNetron.uid).disconnect();
        });

        it("Netron#disconnect(uid)", async (done) => {
            await superNetron.bind();
            await exNetron.connect();

            superNetron.on("peer offline", (peer) => {
                assert.equal(peer.uid, exNetron.uid);
                done();
            });

            superNetron.disconnect(exNetron.uid);
        });

        it("Netron#disconnect()", async (done) => {
            await superNetron.bind();
            await exNetron.connect();

            superNetron.on("peer offline", (peer) => {
                assert.equal(peer.uid, exNetron.uid);
                done();
            });

            superNetron.disconnect();
        });
    });

    describe("events", () => {
        describe("Netron", () => {
            it("peer create", async () => {
                await superNetron.bind();

                const p1 = new Promise((resolve) => {
                    superNetron.on("peer create", () => {
                        resolve();
                    });
                });
                const p2 = new Promise((resolve) => {
                    exNetron.on("peer create", () => {
                        resolve();
                    });
                });

                const p3 = exNetron.connect();
                await Promise.all([p1, p2, p3]);
            });

            it("peer connect", async () => {
                await superNetron.bind();

                const p1 = new Promise((resolve, reject) => {
                    superNetron.on("peer connect", (peer) => {
                        try {
                            assert.equal(peer.uid, null);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                const p2 = new Promise((resolve, reject) => {
                    exNetron.on("peer connect", (peer) => {
                        try {
                            assert.equal(peer.uid, null);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });

                const p3 = exNetron.connect();
                return Promise.all([p1, p2, p3]);
            });

            it("peer online", async () => {
                await superNetron.bind();

                const p1 = new Promise((resolve, reject) => {
                    superNetron.on("peer online", (peer) => {
                        try {
                            assert.equal(peer.uid, exNetron.uid);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                const p2 = new Promise((resolve, reject) => {
                    exNetron.on("peer online", (peer) => {
                        try {
                            assert.equal(peer.uid, superNetron.uid);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });

                const p3 = exNetron.connect();
                return Promise.all([p1, p2, p3]);
            });

            it("peer offline", async () => {
                await superNetron.bind();
                await exNetron.connect();

                const p1 = new Promise((resolve, reject) => {
                    superNetron.on("peer offline", (peer) => {
                        try {
                            assert.equal(peer.uid, exNetron.uid);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });
                const p2 = new Promise((resolve, reject) => {
                    exNetron.on("peer offline", (peer) => {
                        try {
                            assert.equal(peer.uid, superNetron.uid);
                            resolve();
                        } catch (e) {
                            reject(e);
                        }
                    });
                });

                exNetron.disconnect();
                return Promise.all([p1, p2]);
            });
        });

        describe("Peer", () => {
            it("status", (done) => {
                const p = new adone.netron.Peer();
                const newStatus = p.getStatus() + 1;

                p.on("status", (status) => {
                    assert.equal(status, newStatus);
                    done();
                });

                p._setStatus(newStatus);
            });
        });
    });

    describe("Methods overriding", () => {
        let server;

        afterEach(async () => {
            await superNetron.disconnect();
            if (server) {
                await server.disconnect();
                await server.unbind();
                server = undefined;
            }
        });

        describe("onConfirmConnection", () => {
            it("return true", async () => {
                let isOK = false;

                class NewNetron extends Netron {
                    async onConfirmConnection(peer) {
                        assert.instanceOf(peer, adone.netron.Peer);
                        isOK = true;
                        return true;
                    }
                }

                server = new NewNetron(undefined, { restrictAccess: true });
                await server.bind();
                await exNetron.connect();
                assert.ok(isOK);
                exNetron.disconnect();
                await server.unbind();
            });

            it("return false", async () => {
                class NewNetron extends Netron {
                    async onConfirmConnection(peer) {
                        assert.instanceOf(peer, adone.netron.Peer);
                        return false;
                    }
                }

                server = new NewNetron(undefined, { restrictAccess: true });
                await server.bind();

                let resolved = false;
                const peerOffline = new Promise((resolve) => {
                    server.on("peer offline", () => {
                        resolved = true;
                        resolve();
                    });
                });

                const e = await assert.throws(async () => exNetron.connect());
                assert.instanceOf(e, adone.x.Connect);
                assert.include(e.message, "refused connection");
                assert.equal(resolved, false);
            });

            it("disconnect", async () => {
                class NewNetron extends Netron {
                    async onConfirmConnection(peer) {
                        return peer.disconnect();
                    }
                }

                server = new NewNetron(undefined, { restrictAccess: true });
                await server.bind();

                let resolved = false;
                const peerOffline = new Promise((resolve) => {
                    server.on("peer offline", () => {
                        resolved = true;
                        resolve();
                    });
                });

                const e = await assert.throws(async () => exNetron.connect());
                assert.instanceOf(e, adone.x.Connect);
                assert.include(e.message, "refused connection");
                assert.equal(resolved, false);
            });
        });

        describe("onConfirmPeer", () => {
            it("return true", async () => {
                let isOK = false;

                class NewNetron extends Netron {
                    async onConfirmPeer(peer) {
                        assert.instanceOf(peer, adone.netron.Peer);
                        isOK = true;
                        return true;
                    }
                }

                server = new NewNetron();
                await server.bind();
                await exNetron.connect();
                assert.ok(isOK);
                exNetron.disconnect();
                await server.unbind();
            });

            it("return false", async () => {
                class NewNetron extends Netron {
                    async onConfirmPeer(peer) {
                        assert.instanceOf(peer, adone.netron.Peer);
                        return false;
                    }
                }

                server = new NewNetron();
                await server.bind();

                const peerOffline = new Promise((resolve) => {
                    server.on("peer offline", () => {
                        resolve();
                    });
                });

                const e = await assert.throws(async () => exNetron.connect());
                assert.instanceOf(e, adone.x.Connect);
                assert.include(e.message, "refused connection");
                await peerOffline;
            });

            it("disconnect", async () => {
                class NewNetron extends Netron {
                    async onConfirmPeer(peer) {
                        assert.instanceOf(peer, adone.netron.Peer);
                        return peer.disconnect();
                    }
                }

                server = new NewNetron();
                await server.bind();

                const peerOffline = new Promise((resolve) => {
                    server.on("peer offline", () => {
                        resolve();
                    });
                });

                const e = await assert.throws(async () => exNetron.connect());
                assert.instanceOf(e, adone.x.Connect);
                assert.include(e.message, "refused connection");
                await peerOffline;
            });
        });

        describe("onSendHandshake", () => {
            it("check calling", async () => {
                let isOK = false;

                class Client extends Netron {
                    onSendHandshake(peer, packet) {
                        assert.instanceOf(peer, adone.netron.Peer);
                        isOK = true;
                        return super.onSendHandshake(peer, packet);
                    }
                }

                const client = new Client();
                await superNetron.bind();
                await client.connect();
                assert.ok(isOK);
            });

            it("simple authorization", async () => {
                class ServerNetron extends Netron {
                    async onConfirmPeer(peer, packet) {
                        const data = packet.data;
                        if (data.secret === "right secret") {
                            return true;
                        }
                        return false;

                    }
                }

                class ClientNetron extends Netron {
                    constructor(uid, secret) {
                        super(uid);
                        this.secret = secret;
                    }

                    onSendHandshake(peer) {
                        const data = super.onSendHandshake(peer);
                        data.secret = this.secret;
                        return data;
                    }
                }

                server = new ServerNetron();
                await server.bind();

                const client = new ClientNetron("client", "right secret");
                const hacker = new ClientNetron("hacker", "false secret");

                await client.connect();

                const e = await assert.throws(async () => hacker.connect());
                assert.instanceOf(e, adone.x.Connect);
                assert.include(e.message, "refused connection");
            });
        });

        describe("customProcessPacket", () => {
            it.skip("custom action on server", async () => {
                const minAction = ACTION.MAX - 20;
                const maxAction = ACTION.MAX - 1;
                const an = Math.round(minAction + Math.random() * (maxAction - minAction));
                const sendData = "hello";
                const p = new Promise((resolve) => {
                    class ServerNetron extends Netron {
                        customProcessPacket(peer, packet) {
                            super.customProcessPacket(peer, packet).then((res) => {
                                if (!res) {
                                    resolve(packet.data);
                                }
                            });
                        }
                    }

                    server = new ServerNetron();
                });
                await server.bind();
                const serverPeer = await exNetron.connect();
                await exNetron.send(serverPeer, 1, serverPeer.streamId.next(), 1, an, sendData);
                assert.equal(await p, sendData);
            });
        });
    });
});

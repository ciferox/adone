const {
    is,
    netron: { DEFAULT_PORT, Netron, Property, Context, Public }
} = adone;

let defaultPort = DEFAULT_PORT;
let NETRON_PORT = 32348;

describe("netron", "native", "functional tests", () => {
    let exNetron;
    let superNetron;

    before(async () => {
        if (!(await adone.net.util.isFreePort(defaultPort))) {
            defaultPort = adone.net.util.getPort();
        }
        NETRON_PORT = adone.net.util.getPort({ exclude: [defaultPort] });
    });

    beforeEach(async () => {
        exNetron = new Netron();
        superNetron = new Netron({ isSuper: true });
    });

    afterEach(async () => {
        await exNetron.disconnect();
        await superNetron.unbind();
    });

    describe("Unix-Sockets and Windows-pipes", () => {
        const SOCKET_PIPE = is.windows ? "\\\\.\\pipe\\adone_test_pipe" : "test_socket.sock";

        it("two connections", async () => {
            await superNetron.bind({ port: SOCKET_PIPE });

            const n1 = new Netron();
            const n2 = new Netron();
            try {
                await n1.connect({ port: SOCKET_PIPE });
                await n2.connect({ port: SOCKET_PIPE });
            } catch (e) {
                superNetron.disconnect();
                throw e;
            }

            const superNetronPeers = superNetron.getPeers();
            assert.ok(superNetronPeers.has(n1.uid));
            assert.ok(superNetronPeers.has(n2.uid));
            superNetron.disconnect();
        });
    });

    it("Connection: [1] -> [2] -> [3]", async () => {
        const first = new Netron();
        const second = new Netron();
        const third = new Netron();
        let peerFirstToSecond;
        let peerSecondToThird;
        second.bind();
        third.bind({ port: NETRON_PORT, host: "127.0.0.1" });

        try {
            peerFirstToSecond = await first.connect();
            peerSecondToThird = await second.connect({ port: NETRON_PORT, host: "127.0.0.1" });
        } catch (e) {
            assert.ifError(e);
        }

        assert.ok(peerFirstToSecond);
        assert.ok(peerSecondToThird);
        assert.equal(peerFirstToSecond.uid, second.uid);
        assert.equal(peerSecondToThird.uid, third.uid);
        first.disconnect();
        second.disconnect();
        second.unbind();
        third.disconnect();
        third.unbind();
    });

    describe("Events order", () => {
        it("Server", async () => {
            let index = 0;

            const p1 = new Promise((resolve, reject) => {
                superNetron.on("peer create", async () => {
                    try {
                        assert.equal(index++, 0);
                        await adone.promise.delay(300);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            const p2 = new Promise((resolve, reject) => {
                superNetron.on("peer connect", async () => {
                    try {
                        assert.equal(index++, 1);
                        await adone.promise.delay(200);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            const p3 = new Promise((resolve, reject) => {
                superNetron.on("peer online", async () => {
                    try {
                        assert.equal(index++, 2);
                        await adone.promise.delay(100);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            const p4 = new Promise((resolve, reject) => {
                superNetron.on("peer offline", () => {
                    try {
                        assert.equal(index, 3);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            await superNetron.bind();
            await exNetron.connect();
            exNetron.disconnect();

            return Promise.all([p1, p2, p3, p4]);
        });

        it("Client", async () => {
            let index = 0;

            const p1 = new Promise((resolve, reject) => {
                exNetron.on("peer create", async () => {
                    try {
                        assert.equal(index++, 0);
                        await adone.promise.delay(300);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            const p2 = new Promise((resolve, reject) => {
                exNetron.on("peer connect", async () => {
                    try {
                        assert.equal(index++, 1);
                        await adone.promise.delay(200);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            const p3 = new Promise((resolve, reject) => {
                exNetron.on("peer online", async () => {
                    try {
                        assert.equal(index++, 2);
                        await adone.promise.delay(100);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            const p4 = new Promise((resolve, reject) => {
                exNetron.on("peer offline", () => {
                    try {
                        assert.equal(index, 3);
                        resolve();
                    } catch (e) {
                        reject(e);
                    }
                });
            });

            await superNetron.bind();
            await exNetron.connect();
            exNetron.disconnect();

            return Promise.all([p1, p2, p3, p4]);
        });
    });


    describe("Interfacing", () => {
        describe("Exceptions", () => {
            @Context()
            class StdErrs {
                @Public()
                throwError() {
                    throw new Error("description");
                }

                @Public()
                throwEvalError() {
                    throw new EvalError("description");
                }

                @Public()
                throwRangeError() {
                    throw new RangeError("description");
                }

                @Public()
                throwReferenceError() {
                    throw new ReferenceError("description");
                }

                @Public()
                throwSyntaxError() {
                    throw new SyntaxError("description");
                }

                @Public()
                throwTypeError() {
                    throw new TypeError("description");
                }

                @Public()
                throwURIError() {
                    throw new URIError("description");
                }
            }

            for (const i of ["local", "remote"]) {
                // eslint-disable-next-line
                it(`${i} - standart exceptions`, async () => {
                    let okCount = 0;
                    superNetron.attachContext(new StdErrs(), "a");
                    await superNetron.bind({ port: NETRON_PORT });

                    let iA;
                    if (i === "local") {
                        iA = superNetron.getInterfaceByName("a");
                    } else {
                        const peer = await exNetron.connect({ port: NETRON_PORT });
                        iA = peer.getInterfaceByName("a");
                    }
                    const stdErrors = adone.x.stdExceptions;
                    for (const StdError of stdErrors) {
                        try {
                            await iA[`throw${StdError.prototype.name}`]();
                        } catch (err) {
                            okCount += (err instanceof StdError ? 1 : 0);
                        }
                    }
                    assert.ok(okCount === stdErrors.length);
                });
            }

            for (const i of ["local", "remote"]) {
                // eslint-disable-next-line
                it.skip(`${i} - adone exceptions`, async () => {
                    let okCount = 0;

                    @Context()
                    class AdoneErrs { }

                    const adoneErrors = adone.x.adoneExceptions;
                    for (const AdoneError of adoneErrors) {
                        if (adone.x.exceptionIdMap[AdoneError] < 1000) {
                            AdoneErrs.prototype[`throw${AdoneError.prototype.name}`] = function () {
                                throw new AdoneError("description");
                            };
                        }
                    }

                    superNetron.attachContext(new AdoneErrs(), "a");
                    await superNetron.bind({ port: NETRON_PORT });

                    let iA;
                    if (i === "local") {
                        iA = superNetron.getInterfaceByName("a");
                    } else {
                        const peer = await exNetron.connect({ port: NETRON_PORT });
                        iA = peer.getInterfaceByName("a");
                    }

                    for (const AdoneError of adoneErrors) {
                        try {
                            await iA[`throw${AdoneError.prototype.name}`]();
                        } catch (err) {
                            okCount += (err instanceof AdoneError ? 1 : 0);
                        }
                    }
                    assert.ok(okCount === adoneErrors.length);
                });
            }

            for (const i of ["local", "remote"]) {
                it(`${i} - should not fail when a non-standard error is sent`, async () => { // eslint-disable-line
                    class MyError extends Error { }

                    @Context()
                    class NonStdErr {
                        @Public()
                        throw() {
                            throw new MyError("Hello World!");
                        }
                    }

                    superNetron.attachContext(new NonStdErr(), "a");
                    await superNetron.bind({ port: NETRON_PORT });

                    let iA;

                    if (i === "local") {
                        iA = superNetron.getInterfaceByName("a");
                    } else {
                        const peer = await exNetron.connect({ port: NETRON_PORT });
                        iA = peer.getInterfaceByName("a");
                    }

                    await assert.throws(async () => {
                        await iA.throw();
                    }, "Hello World!");
                });
            }

            process.binding("natives").native_module = "";
            const nm = nodeRequire("native_module");
            const nodeErrors = adone.util.omit(nm.require("internal/errors"), ["message", "E"]);

            for (const i of ["local", "remote"]) {
                for (const [name, Exc] of Object.entries(nodeErrors)) {
                    it(`${i} - should not fail when an internal nodejs error '${name}' is sent`, async () => { // eslint-disable-line
                        @Context()
                        class NodeErr {
                            @Public()
                            throw() {
                                if (Exc.name === "AssertionError") {
                                    throw new Exc({
                                        message: "Hello World!"
                                    });
                                }
                                throw new Exc("Hello World!");
                            }
                        }

                        superNetron.attachContext(new NodeErr(), "a");
                        await superNetron.bind({ port: NETRON_PORT });

                        let iA;

                        if (i === "local") {
                            iA = superNetron.getInterfaceByName("a");
                        } else {
                            const peer = await exNetron.connect({ port: NETRON_PORT });
                            iA = peer.getInterfaceByName("a");
                        }

                        await assert.throws(async () => {
                            await iA.throw();
                        }, "Hello World!");
                    });
                }
            }
        });
    });

    describe("Referencing contexts", () => {
        @Context()
        class TheC {
            @Public()
            getValue() {
                return 8;
            }
        }

        @Context()
        class TheB {
            constructor() {
                this.theC = new TheC();
            }

            @Public()
            originateC() {
                return this.theC;
            }

            @Public()
            updateC(c) {
                this.theC = c;
            }
        }

        @Context()
        class TheA {
            constructor() {
                this.theB = new TheB();
                this.theC = new TheC();
            }

            @Public()
            originateB() {
                return this.theB;
            }

            @Public()
            updateB(b) {
                this.theB = b;
            }

            @Public()
            makeUpdateOnB() {
                return this.theB.updateC(this.theC);
            }
        }

        it("obtain unknown interfaces after detach context", async () => {
            const theA = new TheA();
            superNetron.attachContext(theA, "a");
            await superNetron.bind();
            const peer = await exNetron.connect();
            const iTheA = peer.getInterfaceByName("a");
            const aDefId = iTheA.$def.id;
            assert.equal(aDefId, superNetron.getDefinitionByName("a").id);
            await superNetron.detachContext("a");
            await adone.promise.delay(100);
            assert.throws(() => {
                superNetron.getInterfaceById(aDefId);
            }, adone.x.Unknown);
            assert.throws(() => {
                peer.getInterfaceById(aDefId);
            }, adone.x.Unknown);
        });

        it("obtain unknown interfaces after disconnect", async () => {
            const theA = new TheA();
            superNetron.attachContext(theA, "a");
            await superNetron.bind();
            const peer = await exNetron.connect();
            const iTheA = peer.getInterfaceByName("a");
            const theB = new TheB();
            await iTheA.updateB(theB);
            const aDefId = iTheA.$def.id;
            assert.equal(aDefId, superNetron.getDefinitionByName("a").id);
            await exNetron.disconnect();
            await adone.promise.delay(100);
            assert.throws(() => {
                const iA = peer.getInterfaceById(aDefId);
                iA.originateB();
            }, adone.x.Unknown);
        });

        it("inverse object manupulation stub referencing", async () => {
            const theA = new TheA();
            superNetron.attachContext(theA, "a");
            await superNetron.bind();
            const peer = await exNetron.connect();
            const iTheA = peer.getInterfaceByName("a");
            const theB = new TheB();
            await iTheA.updateB(theB);
            await iTheA.makeUpdateOnB();
            assert.equal(superNetron._stubs.size, 2);
            assert.equal(exNetron._stubs.size, 1);
            await exNetron.disconnect();
            await adone.promise.delay(100);
            superNetron.detachContext("a");
            assert.equal(superNetron._stubs.size, 0);
            assert.equal(exNetron._stubs.size, 0);
        });
    });

    // describe("Multiple netrons with same NUIDs", function() {
    //     @Contextable
    //     class Worker {
    //         constructor() {
    //             this.counter = 0;
    //         }

    //         somethingUseful() {
    //             ++this.counter;
    //         }
    //     }

    //     @Contextable
    //     class Cache {
    //         constructor() {
    //             this.storage = [];
    //         }

    //         register(context) {
    //             this.storage.push(context);
    //         }

    //         async spread() {
    //             for (const context of this.storage) {
    //                 try {
    //                     await context.somethingUseful();
    //                 } catch (err) { }
    //             }
    //         }
    //     }

    //     afterEach(async function(){
    //         await superNetron.disconnect();
    //     });

    //     it("interfaces must be inaccesible", async function () {
    //         const cache = new Cache();
    //         superNetron.attachContext(cache, "cache");
    //         await superNetron.bind({ port: NETRON_PORT });

    //         for (let i = 0; i < 10; ++i) {
    //             const client = new Netron();
    //             const peer = await client.connect({ port: NETRON_PORT });
    //             const cache = peer.getInterfaceByName("cache");
    //             await cache.register(new Worker());
    //             await client.disconnect();
    //         }
    //         const client = new Netron();
    //         const peer = await client.connect({ port: NETRON_PORT });
    //         const iCache = peer.getInterfaceByName("cache");
    //         const worker = new Worker();
    //         await iCache.register(worker);
    //         await cache.spread();
    //         assert.equal(worker.counter, 1);
    //         await client.disconnect();
    //     });
    // });

    describe("critical situations", () => {
        afterEach(async () => {
            await superNetron.disconnect();
        });

        it("client crash", async () => {
            await superNetron.bind();

            const code = `
                    require("../../..");
                    let n = new adone.netron.Netron();
                    n.connect({ port: ${DEFAULT_PORT} } )
                    .then(() => console.log("connected"))
                    .catch((error) => console.error(error));
                `;

            const child = adone.std.child_process.spawn("node", [], { stdio: "pipe", cwd: __dirname });

            child.stdin.write(code);
            child.stdin.end();

            return new Promise((resolve, reject) => {
                superNetron.on("peer offline", (peer) => {
                    resolve();
                });

                child.stdout.on("data", (data) => {
                    const msg = data.toString().trim();
                    if (msg === "connected") {
                        child.kill("SIGKILL");
                    } else {
                        reject(new Error(`Unrecognized output from child: ${msg}`));
                    }
                });

                child.stderr.on("data", (data) => {
                    reject(new Error(`Child process error: ${data.toString().trim()}`));
                });

                child.on("error", (error) => {
                    reject(new Error(`Child error: ${error}`));
                });

                child.on("exit", (code, signal) => {
                    if (signal !== "SIGKILL") {
                        reject(new Error(`Uknown exited code (${code}) or signal (${signal})`));
                    }
                });
            });
        });
    });

    describe("Gates", () => {
        @Context()
        class A {
            @Public()
            method1() {
                return "A1";
            }

            @Public()
            method2() {
                return "A2";
            }
        }

        @Context()
        class B {
            @Public()
            method1() {
                return "B1";
            }

            @Public()
            method2() {
                return "B2";
            }
        }

        afterEach(async () => {
            await superNetron.disconnect();
        });

        it("by default all contexts should be accessible", async () => {
            superNetron.attachContext(new A(), "a");
            superNetron.attachContext(new B(), "b");
            await superNetron.bind({
                port: defaultPort,
                access: {

                }
            });

            const peer = await exNetron.connect({
                port: defaultPort
            });

            assert.sameMembers(peer.getContextNames(), ["a", "b"]);
            const iA = peer.getInterfaceByName("a");
            const iB = peer.getInterfaceByName("b");
            assert.equal(await iA.method1(), "A1");
            assert.equal(await iB.method1(), "B1");
        });

        for (const contexts of [undefined, null, []]) {
            // eslint-disable-next-line
            it(`all contextes should be accessible if context = ${contexts}`, async () => {
                superNetron.attachContext(new A(), "a");
                superNetron.attachContext(new B(), "b");
                await superNetron.bind({
                    port: defaultPort,
                    access: {
                        contexts
                    }
                });

                const peer = await exNetron.connect({
                    port: defaultPort
                });

                assert.sameMembers(peer.getContextNames(), ["a", "b"]);
                const iA = peer.getInterfaceByName("a");
                const iB = peer.getInterfaceByName("b");
                assert.equal(await iA.method1(), "A1");
                assert.equal(await iB.method1(), "B1");
            });
        }

        it("should be accessable only enumerated contexts", async () => {
            superNetron.attachContext(new A(), "a");
            superNetron.attachContext(new B(), "b");
            await superNetron.bind({
                port: defaultPort,
                access: {
                    contexts: ["a"]
                }
            });

            const peer = await exNetron.connect({
                port: defaultPort
            });

            assert.sameMembers(peer.getContextNames(), ["a"]);
            const iA = peer.getInterfaceByName("a");
            assert.equal(await iA.method1(), "A1");

            const err = assert.throws(() => peer.getInterfaceByName("b"));
            assert.instanceOf(err, adone.x.Unknown);
        });
    });
});

const path = require("path");
const fs = require("graceful-fs");
const child_process = require("child_process");
const addonPath = path.resolve(__dirname, "node_modules", "hello_world");
const nodeGyp = path.resolve(__dirname, "..", "bin", "node-gyp.js");
const execFileSync = child_process.execFileSync;
const execFile = child_process.execFile;

const {
    gyp: { command: { rebuild } }
} = adone;

const runHello = function () {
    const testCode = "console.log(require('hello_world').hello())";
    return execFileSync("node", ["-e", testCode], { cwd: __dirname }).toString();
};

const getEncoding = function () {
    const code = "import locale;print locale.getdefaultlocale()[1]";
    return execFileSync("python", ["-c", code]).toString().trim();
};

const checkCharmapValid = function () {
    let data;
    try {
        data = execFileSync("python", ["fixtures/test-charmap.py"],
            { cwd: __dirname });
    } catch (err) {
        return false;
    }
    const lines = data.toString().trim().split("\n");
    return lines.pop() === "True";
};

it("build simple addon", () => {
    // Set the loglevel otherwise the output disappears when run via 'npm test'
    const cmd = [nodeGyp, "rebuild", "-C", addonPath, "--loglevel=verbose"];
    const proc = execFile(process.execPath, cmd, (err, stdout, stderr) => {
        const logLines = stderr.toString().trim().split(/\r?\n/);
        const lastLine = logLines[logLines.length - 1];
        assert.strictEqual(err, null);
        assert.strictEqual(lastLine, "gyp info ok", "should end in ok");
        assert.strictEqual(runHello().trim(), "world");
    });
    proc.stdout.setEncoding("utf-8");
    proc.stderr.setEncoding("utf-8");
});

it("build simple addon in path with non-ascii characters", () => {
    if (!checkCharmapValid()) {
        return;
        // return t.skip("python console app can't encode non-ascii character.");
    }

    const testDirNames = {
        cp936: "文件夹",
        cp1252: "Latīna",
        cp932: "フォルダ"
    };
    // Select non-ascii characters by current encoding
    const testDirName = testDirNames[getEncoding()];
    // If encoding is UTF-8 or other then no need to test
    if (!testDirName) {
        return;
        // return t.skip("no need to test");
    }

    const configPath = path.join(addonPath, "build", "config.gypi");
    const data = fs.readFileSync(configPath, "utf8");

    const config = JSON.parse(data.replace(/\#.+\n/, ""));
    const nodeDir = config.variables.nodedir;
    const testNodeDir = path.join(addonPath, testDirName);
    // Create symbol link to path with non-ascii characters
    try {
        fs.symlinkSync(nodeDir, testNodeDir, "dir");
    } catch (err) {
        switch (err.code) {
            case "EEXIST": break;
            case "EPERM":
                throw new Error(err, "Please try to running console as an administrator");
            default:
                throw err;
        }
    }

    const cmd = [nodeGyp, "rebuild", "-C", addonPath,
        "--loglevel=verbose", `-nodedir=${testNodeDir}`];
    const proc = execFile(process.execPath, cmd, (err, stdout, stderr) => {
        fs.unlink(testNodeDir);

        const logLines = stderr.toString().trim().split(/\r?\n/);
        const lastLine = logLines[logLines.length - 1];
        assert.strictEqual(err, null);
        assert.strictEqual(lastLine, "gyp info ok", "should end in ok");
        assert.strictEqual(runHello().trim(), "world");
    });
    proc.stdout.setEncoding("utf-8");
    proc.stderr.setEncoding("utf-8");
});
